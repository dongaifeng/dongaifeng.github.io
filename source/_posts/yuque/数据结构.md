---
title: 数据结构
urlname: nzpgs6
date: '2021-06-24 09:49:56 +0800'
tags: []
categories: []
---

常见的数据结构有

- 队列 Qyeue
- 树 Tree
- 堆 Heap
- 数组 Array
- 栈 Stack
- 链表 LinkedList
- 图 Graph
- 哈希表 Hash

### 队列

Queue 是一种受限制线性表 先进先出(FIFO) 类似于排队买票。只允许在队列头部进行删除操作，在尾部进行插入操作。

```javascript
class Queue {
  constructor() {
    this.items = [];
  }
  // 添加
  enqueue(ele) {
    this.items.push(ele);
  }
  // 从前删除一个元素
  dequeue() {
    return this.items.shift();
  }
  // 查看前端的元素
  front() {
    return this.items[0];
  }
  // 是否为空
  isEmpty() {
    return this.items.length === 0;
  }
  size() {
    return this.items.length;
  }

  toString() {
    let str = "";
    for (let i = 0; i < this.items.length; i++) {
      str += this.items[i] + " ";
    }
    return str;
  }
}
```

### 链表

链表中的元素在内存中不必是连续的，
每一个元素本身有指针指向下一个元素和和指向上一个元素的指针。
创建时不必确定大小长度， 可无限添加。
插入，删除 时间复杂度 O（1）
无论访问任何位置的元素都需要从头开始查找，无法通过下标查找。

#### 单向链表

太简单，不写了

#### 双向链表

直接看图
![a.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1623915460026-9ffa0f2a-7200-453e-bb9a-20cb636be1ba.png#clientId=u5e6241a1-722d-4&from=drop&id=u8cfc0e0e&margin=%5Bobject%20Object%5D&name=a.png&originHeight=192&originWidth=839&originalType=binary∶=1&size=34050&status=done&style=none&taskId=ud0d35ee1-1ea1-4baf-8b0f-5ec26e3450d)

```javascript
class LinkenList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  // 添加
  append(data) {
    let newNode = new Node(data);
    if (this.length === 0) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }
    this.length += 1;
  }

  // 插入节点
  insert(position, data) {
    if (position < 0 || position > this.length) return false;
    let newNode = new Node(data);

    // 如果当前链表为空 就直接插入
    if (this.length === 0) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      // 然后判断position的位置 1 在头 2 在尾 3 在中间
      if (position === 0) {
        // 先将新链表的第一个node的prev指向newNode，然后newNode的next指向 链表第一个node，然后将head指向newNode
        this.head.prev = newNode;
        newNode.next = this.head;
        this.head = newNode;
      } else if (position === this.length) {
        newNode.prev = this.tail;
        this.tail.next = newNode;
        this.tail = newNode;
      } else {
        let current = this.head;
        let index = 0;
        while (index++ < position) {
          // 当index===position时 current 就是链表里position位置的node
          current = current.next;
        }

        newNode.next = current;
        newNode.prev = current.prev;
        current.prev.next = newNode;
        current.prev = newNode;
      }
    }
    this.length += 1;
    return true;
  }

  get(position) {
    if (position < 0 || position > this.length) return false;
    let current = this.head;
    let index = 0;
    while (index++ < position) {
      current = current.next;
    }

    return current.data;
  }

  indexOf(data) {
    if (position < 0 || position > this.length) return false;
    let current = this.head;
    let index = 0;
    while (current) {
      if (current.data === data) {
        return index;
      }
      current = current.next;
      index += 1;
    }

    return -1;
  }

  update(position, newData) {
    if (position < 0 || position > this.length) return false;
    let current = this.head;
    let index = 0;
    while (index++ < position) {
      current = current.next;
    }
    current.data = newData;
    return true;
  }

  removeAt(position) {
    if (position < 0 || position > this.length) return null;
    let index = 0;
    let current = this.head;

    if (this.length == 1) {
      this.head = this.tail = null;
    } else {
      if (position === 0) {
        this.head.next.prev = null;
        this.head = this.head.next;
      } else if (position === this.length - 1) {
        this.tail.prev.next = null;
        this.tail = this.tail.next;
      } else {
        while (index++ < current) {
          current = current.next;
        }
        current.prev.next = current.next;
        current.next.prev = current.prev;
      }

      this.length -= 1;
      return current;
    }
  }

  remove(data) {
    let index = this.indexOf(data);
    return this.removeAt(index);
  }

  // 获取某节点
  get(position) {
    if (position < 0 || position > this.length) return false;
    let flag = position > this.length / 2;
    let current = flag ? this.tail : this.head;
    let index = flag ? this.length : 0;

    while (index < position) {
      index = flag ? --index : ++index;
      current = flag ? current.prev : current.next;
    }

    return current.data;
  }
  toString() {
    return this.backwardString();
  }

  // 从前向后 输出字符串
  backwardString() {
    let current = this.head;
    let str = "";

    while (current) {
      str += current.data + " ";
      current = current.next;
    }

    return str;
  }

  // 从后向前 输出字符串
  forwardString() {
    let current = this.tail;
    let str = "";

    while (current) {
      str += current.data + " ";
      current = current.prev;
    }

    return str;
  }
}

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}
```

### 栈

stack 是一种受限制线性表，后进先出(LIFO), 类似往木桶里装砖块。

```javascript
function Stack() {
  this.items = [];
}

// 压栈
Stack.prototype.push = function (ele) {
  this.items.push(ele);
};
// 从栈中拿出元素
Stack.prototype.pop = function () {
  return this.items.pop();
};

// 查看栈顶元素
Stack.prototype.peek = function () {
  return this.items[this.items.length - 1];
};

// 判断是否为空
Stack.prototype.isEmpty = function () {
  return this.items.length === 0;
};

//
Stack.prototype.clear = function () {
  this.items.length = 0;
};
// 获取元素个数
Stack.prototype.size = function () {
  return this.items.length;
};
// toString 方法 再打印 stack时候会调用
Stack.prototype.toString = function () {
  let str = "";
  for (let i = 0; i < this.items.length; i++) {
    str += this.items[i] + ",";
  }
  return str;
};
```

### 集合

无序的，不能重复，可以看做一种特殊的数组，里面的元素没有顺序，也不能重复。

> 可以直接使用 ES6 的 Set 类

### 字典

一一对应，js 中的对象就是字典

### 哈希表

哈希表比数组快，没有顺序，不允许重复，空间利用率不高。

> 数组结构 数组基于索引查找很快，基于内容查找不高，删除效率不高

### 树

#### 二叉搜索树

非空左子数的所有键值小于其根节点的键值
非空右子树的所有键值大于其根节点的键值
左右子树本身都是二叉搜索树
可能不平衡 非平衡树

#### 红黑树

节点是红色或者黑色，根节点都是黑色，叶子节点都是黑色空节点
每个红节点都有两个黑节点
从任何节点到他的某个叶子节点 所走的路径上遇到的黑节点 都相同

### 图

类似树，只是每个节点直接都可以访问。每个节点交**顶点**，节点与节点的连线叫做**边**

#### 图的遍历

- 广度优先搜索 BFS
  从 A 开始向下一层一层遍历

![d.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1623916872758-5a9bc96d-b213-4437-bd76-14d575ef8e4f.png#clientId=u5e6241a1-722d-4&from=drop&id=u1b3ff97a&margin=%5Bobject%20Object%5D&name=d.png&originHeight=321&originWidth=476&originalType=binary∶=1&size=51822&status=done&style=none&taskId=u58245d88-ee0b-4f83-86b1-2e0caecaa2f)

- 深度优先搜索 DFS
  从 A 开始向下一层 B, B 有两个边，然后再向 B 的第一个边 E 访问，等 E 这条线访问完，再访问 B 上的第二个边，然后 B 访问完了，再访问 A 的第二个边，依次这样下去

![f.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1623916720850-788aadda-55a2-41c1-98b9-44fad8933168.png#clientId=u5e6241a1-722d-4&from=paste&height=287&id=ua1e1e7d3&margin=%5Bobject%20Object%5D&name=f.png&originHeight=287&originWidth=386&originalType=binary∶=1&size=34177&status=done&style=none&taskId=u64602802-745a-4316-8999-770ed3ca7ce&width=386)

#### 邻接矩阵表示图

![b.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/462392/1623916773346-130bbe3c-cc1f-44a1-a050-51b0cc30882d.jpeg#clientId=u5e6241a1-722d-4&from=paste&height=423&id=u64a54621&margin=%5Bobject%20Object%5D&name=b.jpg&originHeight=423&originWidth=835&originalType=binary∶=1&size=87079&status=done&style=none&taskId=u3cc607ae-836d-46f1-a2ae-a0679c156dc&width=835)
如果 A - B 交叉的节点数字是 1 ，表示 A B 之间有边，若果 A - B 交叉的节点数字是 0 ，表示 A B 之前无边

> 邻接矩阵，只能表示无向图，而且 A A 的交叉点会浪费空间。

#### 邻接表

![c.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1623916783511-74f019d1-2f41-4105-8a6c-0c8e8a99cd8c.png#clientId=u5e6241a1-722d-4&from=paste&height=520&id=u9411dbe1&margin=%5Bobject%20Object%5D&name=c.png&originHeight=520&originWidth=846&originalType=binary∶=1&size=85848&status=done&style=none&taskId=u70e23e07-14e7-4a70-99ba-c502667757e&width=846)

A 对应的是一个数组，里面放着 B，C，D。表示 A->B, A->C, A->D.他们指向是右边，且有方向。

# 算法

### 大 O 表示法

| 符号       | 名称           |
| ---------- | -------------- |
| O(1)       | 常数的         |
| O(log(n))  | 对数的         |
| O(n)       | 线性的         |
| O(nlog(n)) | 线性和对数乘积 |
| O(n\*n)    | 平方           |

规则

- 用常量 1 取代运行时间中所有的加法常量
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高存在而且不为 1，则去除与这个项相乘的常数

### 排序算法

#### 冒泡排序

拿到下标 0,跟相邻的下标 1 的元素比较，如果 0 的位置元素大，那就互换位置，然后下标 1 再和下标 2 的元素比较，如果 1 位置的元素大，那就互换，这样遍历一遍，最大的那个元素肯定放到最后了。然后再从 0 和 1 的位置开始比较，这次遍历到下标 length-2 的位置，因为最后的那个元素最大不用比较了，这次遍历完，length-3 的位置就是第二大的元素。据这样依次找到个元素的位置.

```javascript
ArrayList.prototype.bubbleSort = function () {
  let length = this.arr.length;
  // 反向遍历 设置内层循环的终点
  for (let k = length - 1; k >= 0; k--) {
    // 遍历 比较 i， i+1 位置的元素
    for (var i = 0; i < k; i++) {
      if (this.arr[i] > this.arr[i + 1]) {
        this.swap(i, i + 1); // 交换位置
      }
    }
  }
};
```

对于 N 个数据的数组，一共比较 (N - 1) + (N - 2) + (N - 3) + ... + 1 = N \* (N - 1) / 2。
用大 O 表示法表示:

1. 根据规则 2 只保留最高阶项。N \* (N - 1) / 2 = N²/2 - N/2 也就是  N²/2
1. 根据规则 3 如果最高阶项存在并且不是 1，则去除与这个项相乘的乘数。 那就是 N²/2 去除 1/2。也就是 N²
1. 因为冒泡排序的大 O 是 O(N²)

### 选择排序

拿出下标为 0 位置的数据，跟后边所有的数据依次比较，只要找到比他小的就互换，这样遍历下来，下标为 0 的，肯定是最小的。然后拿出下标为 1 的依次跟后面的比较，这样就找到第二小的数据。
**选择排序的交换次数只有 N-1 次, 用大 O 表示法就是 O(N)**

```javascript
function selectSort(arr) {
  for (let j = 0; j < arr.length - 1; j++) {
    let minIndex = j;

    for (let i = j + 1; i < arr.length; i++) {
      if (arr[minIndex] > arr[i]) {
        minIndex = i;
      }
    }

    let temp = arr[j];
    arr[j] = arr[minIndex];
    arr[minIndex] = temp;
  }
}
```

### 插入排序

我们假如 0 的位置到数组头部的数都是有序的。拿出下标 1 位置的数，作为基数，去跟他之前的数比较，如果他之前的数比他大，就互换，一直比到比他小的位置。然后再拿出 2 位置的数跟他之前的数比较。这样就做到了基数之前的数都是有序的。

```javascript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let temp = arr[i];
    let j = i;

    while (temp < arr[j - 1] && j > 0) {
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = temp;
  }
}
```

### 希尔排序

希尔算法是在插入排序的基础上，做了一层分组。
先找一个增量（一般是长度的一半），从头开始以增量的长度分组。

> 比如 0， 0+增量，0+增量+增量 是一组。1， 1+增量，1+增量+增量是一组

然后每组再进行插入排序。
然后增量减小，再分组，再插入排序。
最后增量为 1，就是正确的排序了。

```javascript
ArrayList.prototype.shellSort = function () {
  let length = this.arr.length;
  // 计算增量 步长
  let gap = Math.floor(length / 2);

  // 增量不断减小， 直到为1
  while (gap > 0) {
    // 插入排序 这里不是比较基数之前的数了，
    // 而是把 0， 0+gap， 0+gap+gap ...等拿出来依次比较
    // 相当于 基数跟 基数-gap比较大小互换，再跟 基数-2*gap比较
    for (var i = gap; i < length; i++) {
      let j = i; // 保存基数的位置，也就是第一个增量的位置
      let temp = this.arr[i]; // 保存基数值

      // 当基数比 基数-gap位置的值小，就互换，直到gap位置
      while (j > gap - 1 && this.arr[j - gap] > temp) {
        this.arr[j] = this.arr[j - gap];
        j -= gap;
      }

      this.arr[j] = temp;
    }
    // 重新计算步长，相当于减小步长
    gap = Math.floor(gap / 2);
  }
};
```

### 快速排序

快排的思想是：
找一个基准点，然后将小于基准点的所有数放到基准点的左边，大于基准点的数放到右边。
这样基准点就找到了它正确的位置。
然后把左边部分和右边部分递归执行以上操作。
代码分析：

1. 从 quickSort 开始，两个指针分别是数组的头，尾。
1. 然后 if（i < j）设置结束递归条件。
1. 然后，从尾部向前找比基准点小的数，找到了就赋值给 i 的位置，此时 i 位置上的数已经被保存为 piovt。而 j 位置已经空了。
1. 然后从头部向尾部出发，找比基准点大的数，找到了就赋值给 j 位置。此时 j 位置在上一步已经是空的了。这样就完成了互换。
1. 然后再从第 3 步重新开始，最后 i = j 时退出循环，这时候 i 的位置就是基准点的正确位置。
1. 然后左边部分，右边部分递归执行以上操作。

```javascript
ArrayList.prototype.quickSort = function () {
  this.quick(0, this.arr.length - 1);
};

ArrayList.prototype.quick = function (i, j) {
  if (i < j) {
    let left = i;
    let right = j;
    let pivot = this.arr[left];
    while (i < j) {
      while (this.arr[j] >= pivot && i < j) {
        // 从后往前找比基准小的数
        j--;
      }
      if (i < j) {
        this.arr[i++] = this.arr[j];
      }
      while (this.arr[i] <= pivot && i < j) {
        // 从前往后找比基准大的数
        i++;
      }
      if (i < j) {
        this.arr[j--] = this.arr[i];
      }
    }
    this.arr[i] = pivot;
    this.quick(left, i - 1);
    this.quick(i + 1, right);
  }
};
```
