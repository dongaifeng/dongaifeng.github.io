---
title: 危急值微前端框架项目总结
urlname: gvngma
date: '2021-06-24 09:48:55 +0800'
tags: []
categories: []
---

## 前期使用 iframe + postMessage 架构

### postMessage

postMessage 是 html5 引入的 API，postMessage()方法允许来自不同源的脚本采用异步方式进行有效的通信。提供了一种**受控机制**来规避此限制，只要正确的使用，这种方法就很安全。
可以实现跨文本文档,多窗口,跨域消息传递.多用于窗口间数据通信,这也使它成为跨域通信的一种有效的解决方案。
除 IE 浏览器的支持度比较低外,,其他浏览器的支持度良好。

```
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

参数说明：

- otherWindow：窗口的一个引用,比如 iframe 的 contentWindow 属性,执行 window.open 返回的窗口对象,或者是命名过的或数值索引的 window.frames.
- message：要发送到其他窗口的数据。它将会被序列化。而无需自己序列化。
- targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，设置为通配符"\*"表示可以发送到任何窗口,但通常处于安全性考虑不建议这么做.如果想要发送到与当前窗口同源的窗口,可设置为"/"。
- transfer：可选属性。是一串和 message 同时传递的 [Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable) 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

```javascript
window.addEventListener("message", receiveMessage, false);

function receiveMessage(event) {
  var origin = event.origin;
  console.log(event);
}
```

event 对象：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1621923122455-cbaf86c0-f967-47f1-ae9b-9eb93390f96b.png#clientId=uf9f7e612-05d7-4&from=paste&id=uad522c4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=447&originWidth=1091&originalType=binary∶=1&size=51215&status=done&style=shadow&taskId=u20db4258-8e35-4b4e-b8af-7087cc4b5f7)
一些常用的属性：

- data : 指的是从其他窗口发送过来的消息对象;
- type: 指的是发送消息的类型;
- source: 指的是发送消息的窗口对象;
- origin: 指的是发送消息的窗口的源

postMessage 缺点：

- postMessage 是向一个窗口 Post 一个消息，并且不再关注该消息是否被处理。直接返回。
- PostMessage 函数将一个消息放入与创建这个窗口的消息队列相关的线程中，并立刻返回不等待线程处理消息。PostMessage 只是将消息放到消息队列中。

### 设计思路

在 appMain 展示区嵌入 iframe 用来展示页面
监听路由的改变，触发 postMessage 向指定的 iframe 发送路由信息
在 appMain 组件 mounted 的时候 addEventListener 监听 message 事件。destoryed 时候销毁事件。
根据 message 消息的 cmd 属性，分别调用封装的 api。openModel，closeModel，routerPush 等方法。

```vue
<template>
  <iframe
    ref="iframe"
    :src="src"
    width="100%"
    frameborder="0"
    style="background: #fff;height: 90vh;"
  />
</template>

<script>
export default {
  watch: {
    $route() {
      this.postMessage();
    },
  },

  mounted() {
    window.addEventListener("message", this.handleMessage);
  },

  methods: {
    postMessage() {
      this.$refs.iframe.contentWindow.postMessage(
        {
          cmd: this.key,
          params: {},
        },
        "*"
      );
    },

    handleMessage(event) {
      const data = event.data;

      if (data.cmd === "showModel") {
        this.$showModel();
      } else if (data.cmd === "closeModel") {
        this.$closeModel();
      } else {
        this.$router.push(data.cmd);
      }
    },
  },
};
</script>

// 子程序中main.js window.addEventListener('message', function(event) {
window.location.hash = event.data.cmd })
```

### 优缺点

登录状态无法共享， 模态框不能全局，iframe 无法同步全局点击状态。
开发，打包体验不好。
iframe 页面无法缓存页面。

## qiankun 方案

将前端分解成一些更小，更简单的应用，能独立开发，部署，测试。而在界面上看仍然是一个内聚的单一的产品。
核心价值：与技术栈无关，独立开发，独立部署，增量升级（通常很难对一个已存在的系统做完整的升级重构，而微前端可以做渐进式的更新重构），每个微应用之间状态独立，独立运行，独立部署。
解决多个团队维护同一个项目，技术栈不同，人员差异大的问题，项目在很长的时间跨度下，需求不断增多的问题。

### 为什么使用？

与技术栈无关，vue，react，jquery 都可以。
样式隔离，微应用之前样式互不干扰。
js 沙箱，确保全局变量不冲突。
资源预加载，浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
基于 single-spa 提供开箱即用的 api。
html entry 方式接入微应用。

### 做了什么？

#### 定义概念

**基座**：主程序，承载项目菜单权限，用户登录登出功能。具有数据中心模块，与子程序共享登录态。
**微程序**：子程序。并不是以页面划分，如果几个页面之间有业务联系，我们就认为它们是同一子应用。
**数据中心**：存在于基座中的一个 vuex 的 state，基座和子应用都可获取，修改。数据被修改后会同步到子应用。(去中心化，即每个应用都有一个完整的数据中心)。
我的做法是：
在子应用，手动注册一个 vuex 的 state，叫做 global。使用的是 vuex 的 store.registerModule 方法。
提供一个 action：setGlobalState。它会触发 prop.setGlobalState 去通知基座更新 state，并且修改自己的 globalState。
提供一个 initGlobalState 初始化自己的 state，只用于 mount 时同步父应用的数据。

初始化状态就是基座中的 vuex 的 globalState 的引用。我们会在基座中封装一个 getGlobalState 方法，导出基座的 globalState 的引用，通过 prop 下发到每个子应用中。
另一种方案：就是通过 prop.onGlobalStateChange 去 dispatch 子应用的 setGlobalState 。

#### 定义 cli

commander 命令行界面
download-git-repo 从 github 上下载项目
inquirer 交互式命令行，可以让用户输入

详细步骤：[https://www.yuque.com/dongaifeng/notes/qtofeg](https://www.yuque.com/dongaifeng/notes/qtofeg)

#### common 模块，公共代码

一些每个项目都会用的工具函数，公共方法，组件提取成 common 模块，统一维护。

```json
// 提取请求接口的方法函数，通过函数传参的方式定制化每个项目的baseUrl
function createRequest(axios, Message, store, getToken, baseURL) {
  const service = axios.create({
    baseURL,
    withCredentials: false,
    timeout: 10000
  })
  return service
}


// 提取注册全局状态的方法，并提供修改，初始化全局状态的action
function registerGlobalModule (store, props = {}) {

  if (!store || !store.hasModule) {
    return;
  }

  actions = {
    setGlobalState ({ commit }, payload) {},  // 子应用改变state并通知父应用

    initGlobalState ({ commit }, payload) {},  // 初始化，只用于mount时同步父应用的数据
  }

  store.registerModule('global', globalModule);
};

// 提取公共组件
Com-Form
Com-Table
Com-Header
Com-Tree
Com-Icon
```

公共模块的引入方式有以下三种方案：

##### webpack 的联邦模块

##### npm 发布后使用

发布道 npm 仓库后使用

##### npm link

1. 首先进入 common 文件夹，控制台输入 npm link
1. 然后进入项目 project1，控制台输入 npm link common
1. 这就将这个公共的项目通过软连接的方式引入到项目里面来了。下图可以看到在 node_modules 中 common 包和其他的包文件夹样式是不一样的，common 文件夹只是一个软链接。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/462392/1621997577058-4b03a08f-9bb6-48ef-b1d7-2bca5a9feefc.png#clientId=uf9f7e612-05d7-4&from=paste&height=442&id=u44a89a7c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=442&originWidth=638&originalType=binary∶=1&size=46544&status=done&style=none&taskId=u7f33b952-83c3-4c30-b13f-ff7a0c41dfe&width=638)
这时修改 common 项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。
需要注意的是，当项目包依赖更新后，也就是执行了 npm install xxx 之后，需要重新 link common 项目。而且使用 npm link 后本地 package.json 里没有记录，无法直观的查看本地包的引用。

##### npm 本地 file 引用

在项目根目录，输入命令： npm install ../common/
其中…/common/是 common 的相对路径，这里也可以输入绝对路径。
这样就将 common 这个工程以 node_module 的方式引入到 project1 和 project2 项目中了。可以正常使用 common 在 index.js 中导出的组件了。
命令执行完后，package.json 里会多一条记录

```json
"dependencies": {
  "common": "file:../common",
  "core-js": "^3.3.2",
  "vue": "^2.6.10",
  "vue-router": "^3.1.3",
  "vuex": "^3.0.1",
  "we-vue": "^2.3.3"
},

```

也可以在 package.json 里加上"ak-commonjs": “file:…/common” 这一行再执行 npm install 命令。
同样这时修改 common 项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。而且在 package.json 中有引入记录。
参考链接：[链接](https://blog.csdn.net/milugloomy/article/details/103187370?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1331973.8062.16185626323224421&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

#### 统一命令

npm-run-all
npm-run-all 提供一下子运行多条命令的功能。主要参数有：

- --parallel: 并行运行多个命令，例如：npm-run-all --parallel lint build
- --serial: 多个命令按排列顺序执行，例如：npm-run-all --serial clean lint build:\*\*
- --continue-on-error: 是否忽略错误，添加此参数 npm-run-all 会自动退出出错的命令，继续运行正常的
- --race: 添加此参数之后，只要有一个命令运行出错，那么 npm-run-all 就会结束掉全部的命令

```json
{
  "start": "npm-run-all --parallel start:*",
  "start:main": "cd main && npm start",
  "dev": "npm-run-all --parallel dev:**",
  "dev:start": "nodemon --watch build exec node \"build/bundle.js\"",
  "dev:build:client": "webpack --config webpack.config.client.js --watch",
  "dev:build:server": "webpack --config webpack.config.server.js --watch"
}
```

#### 模块生成

- 微程序项目的生成，拒绝复制粘贴。使用公司的 cli。
- 命令行生成，page，router，model。

#### 数据 mock

## 组件的封装？

## 项目的优化？

## 总结？

遇到的问题，如何解决
