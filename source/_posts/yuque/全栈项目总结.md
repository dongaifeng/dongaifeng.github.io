---
title: 全栈项目总结
urlname: zr2gbm
date: '2020-09-08 18:59:14 +0800'
tags: []
categories: []
---

#### 生成验证码图

[svg-captcha](https://github.com/produck/svg-captcha/blob/1.x/README_CN.md)

#### 密码加密

md5

#### 邮箱验证

[nodemailer](https://nodemailer.com/about/)

#### jwt

[jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)

#### 使用 egg-router-group 把路由分模块

```javascript
module.exports = (app) => {
  const { router, controller } = app;
  router.get("/", controller.home.index);

  // /user 回去找user模块 => controller.user
  router.group({ name: "user", prefix: "/user" }, (router) => {
    const { info, login, register, verify } = controller.user;

    router.post("/login", login);
    router.post("/register", register);
    router.get("/info", info);
    router.get("/verify", verify);
  });
};
```

#### egg-validate 验证请求的参数

```javascript
const BaseController = require("./base"); // 这是自定义的基础类

// 定义验证规则
const createRule = {
  email: { type: "email" },
  passwd: { type: "string" },
  captcha: { type: "string" },
  nickname: { type: "string" },
};

class UserController extends BaseController {
  async register() {
    const { ctx } = this;
    try {
      ctx.validate(createRule); // 使用
    } catch (e) {}
  }
}
module.exports = UserController;
```

### controller

#### 在声明的 controller 类里，我们通过 this 可以获取到:

- ctx 上下文 Context 的实例对象，它上面有框架封装好的 处理当前请求的属性和方法。
- app 应用  Application  的实例对象，它上面有框架提供的全局对象和方法。
- service 就是自己定义的 Service 的实例对象，等价于  ` this.ctx.service``。 `
- config 应用运行时的[配置项](https://eggjs.org/zh-cn/basics/config.html)。config 文件夹下的所有配置。
- logger logger 对象，上面有四个方法（`debug`，`info`，`warn`，`error`）等价于 ctx.logger。

#### 其实 controller 也可以写成一个个的函数形式，不推荐

```javascript
// app/controller/post.js
exports.create = (ctx) => {};

exports.update = (ctx) => {};
```

#### 获取参数

- this.ctx.query get 请求的参数，?后面的。
- this.ctx.queries 获取全部的 get 参数，包括参数名重复的。
- this.ctx.params 获取路由里的参数，比如：/user/:id/detail/:code.就是 this.ctx.params = {id: '', code: ''}
- this.ctx.request.body post 的参数
- this.ctx.body 是设置响应的数据，相当于 this.ctx.response.body
- this.ctx.request.files[0 获取上传的文件。对于多个文件，我们借助  ctx.request.files  属性进行遍历。
- this.ctx.getFileStream() 获取到上传的文件流.
- this.ctx.headers 获取 header 对象。ctx.headers，ctx.header，ctx.request.headers，ctx.request.header 是一样的
- this.ctx.get(name) 获取请求 header 中的一个字段的值。等价于 ctx.request.get(name)

#### 设置响应

- ctx.status = 201 设置状态码 http 的状态码，不是自己的。
- ctx.body = "" || {} 设置返回数据。
- ctx.render('home.tpl', { name: 'egg' }) 返回渲染模板。
- ctx.set(key, value) 设置一个响应头。
- ctx.set(headers)  设置多个 Header。
- ctx.redirect(url)  重定向。

#### Application 全局应用对象。

全局对象上的事件：

- `server`: 该事件一个 worker 进程只会触发一次，在 HTTP 服务完成启动后，会将 HTTP server 通过这个事件暴露出来给开发者。
- `error`: 运行时有任何的异常被 onerror 插件捕获后，都会触发 `error` 事件，将错误对象和关联的上下文（如果有）暴露给开发者，可以进行自定义的日志记录上报等处理。
- `request` 和 `response`: 应用收到请求和响应请求时，分别会触发 `request` 和 `response` 事件，并将当前请求上下文暴露出来，开发者可以监听这两个事件来进行日志记录。

```javascript
// app.js
module.exports = (app) => {
  app.once("server", (server) => {
    // websocket
  });
  app.on("error", (err, ctx) => {
    // report error
  });
  app.on("request", (ctx) => {
    // log receive request
  });
  app.on("response", (ctx) => {
    // ctx.starttime is set by framework
    const used = Date.now() - ctx.starttime;
    // log total cost
  });
};
```

在 Controller，Service，Schedule 等这些类里都可获取到 app。也可在这些文件夹下 export 一个函数，参数就是 app。也可在类里通过：this.app， this.ctx.app 获取。

#### Context 请求级别的对象。

每一次请求都会实例化一个 Context 上下文对象。这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的  [Service](https://eggjs.org/zh-cn/basics/service.html)  挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（[egg-sequelize](https://github.com/eggjs/egg-sequelize)  会将所有的 model 挂载在 Context 上）。

在  [Middleware](https://eggjs.org/zh-cn/basics/middleware.html), [Controller](https://eggjs.org/zh-cn/basics/controller.html)  以及  [Service](https://eggjs.org/zh-cn/basics/service.html)  中 通过 this.ctx 获取到。

#### nuxt 插件

```javascript
// nuxt 插件机制 可以导出一个函数，这个函数第一个参数是context，它上边包含app，store，route等很多东西
// 第二个参数 是 inject 调用这个函数 可以将 方法同时注入到 context，Vue，vuex
export default ({ app, store, redirect }, inject) => {
  inject("myInjectedFunction", (string) =>
    console.log("That was easy!", string)
  );
};
```

#### 拖拽上传和进度条

- 利用 axios 的 onUploadProgress 监听上传事件

```javascript
// `onUploadProgress` 允许为上传处理进度事件
  onUploadProgress: function (progressEvent) {
    // 对原生进度事件的处理
  },

  // `onDownloadProgress` 允许为下载处理进度事件
  onDownloadProgress: function (progressEvent) {
    // 对原生进度事件的处理
  },
```

[axios 官网](https://www.kancloud.cn/yunye/axios/234845)

- 利用 drag 事件 实现拖拽上传。

[drag 事件](https://blog.csdn.net/hsl0530hsl/article/details/88344225)

#### 判断图片格式

判断前 gif 格式，截取 file 前六个字符，通过 [FileReader](https://www.cnblogs.com/wkrbky/p/6243286.html) 的 readAsBinaryString 方法 把字符换成二进制，再 charCodeAt() 变成 ascii 码，再 toString(16) 变成十六进制。再跟 gif 格式文件的头信息比较
_'47 49 46 38 37 61'  "47 49 46 38 39 61" 可以判断是不是 gif 格式。_

```javascript
async isgif(file) {
  // '47 49 46 38 37 61'  "47 49 46 38 39 61"
  //  G  I  F  8  9(7) a
  let str = file.slice(0, 6)
  const res = await this.blobToString(str)
  const isgif = (res === '47 49 46 38 37 61') || (res === '47 49 46 38 39 61')
  return isgif
},

blobToString(blob) {
  return new Promise((rsolve, reject) => {
    const render = new FileReader()
    render.readAsBinaryString(blob)
    render.onload = function(e){
      const ret = e.target.result.split('')
      .map(v => v.charCodeAt())
      .map(v => v.toString(16))
      .join( ' ')
      console.log("--->",ret)

      rsolve(ret)
    }
  })
}
```

```javascript
//十进制转其他
var x = 110;
console.log(x);
console.log(x.toString(2));
console.log(x.toString(8));
console.log(x.toString(16));
console.log(x.toString(32));

//其他转十进制
console.log(parseInt("1101110", 2));
console.log(parseInt("156", 8));
console.log(parseInt("6e", 16));

// 字符串转ascii码，用charCodeAt();
//ascii码转字符串，用fromCharCode();
var str = "A";
var code = str.charCodeAt();
var str2 = String.fromCharCode(code);
console.log(code, str2);

// 将字符串转换成二进制形式  多个字符的 中间用空格隔开
var a = "我";
console.log(a.charCodeAt()); //25105
console.log(a.charCodeAt().toString(2)); //110001000010001

//将二进制字符串转换成Unicode字符串
var b = "110001000010001";
var asciiCode = parseInt(b, 2);
var charValue = String.fromCharCode(asciiCode);
console.log(asciiCode, charValue);
```

#### requestIdleCallback

**`window.requestIdleCallback()`**方法将在浏览器的空闲时段内调用的函数排队。这使我们能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间`timeout`，则有可能为了在超时前执行函数而打乱执行顺序。

```javascript
// handle 返回一个唯一 id
// timeout 表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。
var handle = window.requestIdleCallback(callback，timeout);

var callback = (deadline) => {
  deadline.timeRemaining() // 剩余时间
  deadline.didTmieout // 布尔值，表示任务是否超时
}
```

[参考链接](https://juejin.im/post/6844903848981577735) [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)

#### 分片上传文件

1 拿到上传文件的对象 file，是一个二进制文件，可以当作字符串。直接用字符串的 slice 方法切割成多个碎片。
2 利用 web woker 或者空余时间，计算出文件的的唯一表示 hash 值，这是通过 MD5 计算二进制流得到的。
3 把每个碎片依次发送到后端。FormData 格式。
4 后端接到每个碎片，以 hash 值创建文件夹，把碎片依次放到这个文件夹。
5 前端发出合并文件请求，后端通过 fse.readdir 把碎片读出 变成数组，然后排序，然后把这个数组换成碎片的路径。
6 通过 fse.createReadStream 把碎片读成 stream 流，然后通过 fse.createWriteStream 把流依次写入要生成的文件。

#### md 编辑器

使用插件 [marked](https://github.com/markedjs/marked)
高亮代码插件 [高亮 highlight](https://github.com/highlightjs/highlight.js/#getting-the-library)
