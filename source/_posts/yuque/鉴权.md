---
title: 鉴权
urlname: ubbt37
date: '2020-09-08 18:59:14 +0800'
tags: []
categories: []
---

### cookie

Header 中的 Set-Cookie 可以设置 cookie
req.headers.cookie 获取 cookie

```javascript
res.setHeader('Set-Cookie', 'cookie1=abc;')；
console.log('cookie:', req.headers.cookie)
```

### koa-session

原理：
往 app.context 上挂载了 session 对象。这个 session 对象是由 koa-session 生成。
在 app.context 上定义 Symbol 变量保存 contextSession 对象，他是私有的外部访问不到。
定义 ctx.session 的 getter/setter。指向 contextSession 对象。
每次 set 的时候，判断是否传输了参数 store  如果没有就 initFromCookie。将数据存入 cookie。

```javascript
const koa = require("koa");
const app = new koa();
const session = require("koa-session");

// 使用koa-redis存储数据
const redisStore = require("koa-redis");
const redis = require("redis");
const redisClient = redis.createClient(3333, "localhost");

const wrapper = require("co-redis");
const client = wrapper(redisClient);

app.keys = ["13232"]; // 签名 用来对cookie进行签名

const SESS_CONFIG = {
  key: "daf:sess", // 键名
  maxAge: 5556,
  httpOnly: true, // 只服务器可修改
  signed: true, // 签名cookie
  //store: redisStore({client}) // 使用redis存数
};

app.use(session(SESS_CONFIG, app));

app
  .use((ctx) => {
    if (ctx.path === "/favicon.ico") return;

    console.log(ctx.session.count);
    let n = ctx.session.count || 0;
    ctx.session.count = ++n;
    ctx.body = n + "次点击率";
  })
  .listen(3000);
```

### session-cookie 模式登录

```javascript
const Koa = require("koa");
const router = require("koa-router")();
const session = require("koa-session");
const cors = require("koa2-cors"); // 应答跨域请求实现
const bodyParser = require("koa-bodyparser");
const static = require("koa-static");
const app = new Koa();
// 配置session中间件
app.use(
  cors({
    credentials: true,
  })
);
// 签名
app.keys = ["secret"];

app.use(static(__dirname + "/"));
app.use(bodyParser());
app.use(session(app));

// 没吃请求进来 判断是login直接去下一步，不是login就判断有没有用户信息 没有就阻止请求
app.use((ctx, next) => {
  if (ctx.url.indexOf("login") > -1) {
    next();
  } else {
    console.log("session", ctx.session.userinfo);
    if (!ctx.session.userinfo) {
      ctx.body = { message: "没有用户信息" };
    } else {
      next();
    }
  }
});

// 登录验证成功 存入session
router.post("/login", async (ctx) => {
  const { body } = ctx.request;
  console.log("body", body);
  ctx.session.userinfo = body.username;
  ctx.body = { message: "登录了 存了session" };
});

router.post("/logout", async (ctx) => {
  delete ctx.session.userinfo;
  ctx.body = { message: "删除了session里的数据" };
});

router.get("/getUser", async (ctx) => {
  ctx.body = {
    message: "获取用户信息",
    userinfo: ctx.session.userinfo,
  };
});

app.use(router.routes());
// allowedMethods处理的业务是当所有路由中间件执行完成之后,
// 若ctx.status为空或者404的时候,丰富response对象的header头
app.use(router.allowedMethods());
app.listen(3000);
```

### token  登录

- 1. 客户端使⽤⽤户名跟密码请求登录
- 2. 服务端收到请求，去验证⽤户名与密码
- 3. 验证成功后，服务端会签发⼀个令牌(Token)，再把这个 Token 发送给客户端
- 4. 客户端收到 Token 以后可以把它存储起来，⽐如放在 Cookie ⾥或者 Local Storage
     ⾥
- 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
- 6. 服务端收到请求，然后去验证客户端请求⾥⾯带着的 Token，如果验证成功，就向客户端返回
     请求的数据

#### jwt 使用

前端需要在亲求头中设置 Authorization 字段，存放 token
Bearer 是 JWT 的认证头部信息

```
axios.defaults.headers["Authorization"] = "Bearer " + token;
```

jwt 分三部分
Header 部分   描述 JWT 元数据
payload  存放要传递的数据
signature  签名

```javascript
// 生成token，第一个参数是数据，第二个是签名，第三个是选项 可选，回调也可选
jwt.sign(
  { foo: "bar" },
  privateKey,
  { algorithm: "RS256" },
  function (err, token) {
    console.log(token);
  }
);
// 解析token
jwt.verify(token, "wrong-secret", function (err, decoded) {
  // err
  // decoded 是数据
});
```

#### koa-jwt

```javascript
app.use(jwt(secret, passthrough, key}))
// secret 是签名。passthrough设置是否传道下一个中间件，key 字段可代替ctx.state.user中的user字段
```

```javascript
const Koa = require("koa");
const router = require("koa-router")();
const jwt = require("jsonwebtoken");
const jwtAuth = require("koa-jwt");
const cors = require("koa2-cors");
const bodyParser = require("koa-bodyparser");
const static = require("koa-static");
const app = new Koa();

const secret = "it's a secret";
app.keys = ["some secret"];
app.use(static(__dirname + "/"));
app.use(bodyParser());

router.post("/login", async (ctx) => {
  const { body } = ctx.request;
  // jwt使用
  const userinfo = body.username;
  ctx.body = {
    message: "登录了",
    userinfo: userinfo,
    token: jwt.sign(
      {
        data: userinfo,
        exp: Math.floor(Date.now() / 1000) + 60 * 60,
      },
      secret
    ),
  };
});

router.get("/getUser", jwtAuth({ secret }), async (ctx) => {
  console.log(ctx.state.user);
  ctx.body = {
    message: "获取数据成功",
    userinfo: ctx.state.user.data,
  };
});

app.use(router.routes());
app.use(router.allowedMethods());
app.listen(3000);
```

### sso  单点登录

流程图：

![未命名文件.png](https://cdn.nlark.com/yuque/0/2019/png/462392/1577343360057-1b2746f7-6762-4a54-89e1-2001894cdd5c.png#align=left&display=inline&height=849&name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png&originHeight=849&originWidth=885&size=70912&status=done&style=none&width=885)
代码在这里：[链接](https://github.com/su37josephxia/kaikeba-code/tree/master/node/06/sso)
